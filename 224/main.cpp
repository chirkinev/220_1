#include <string>
#include <iostream>
#include <cstdint>
#include <algorithm>
#include <iterator>
#include <memory>
#include "Header.h"
#include <vector>
#include <list>
#include <deque>
#include <set>
#include <queue>
#include <stack>

//using namespace std;

int main()
{


	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 1. Реализуйте вычисление факториала с помощью constexpr-функции.
	//
	//Подсказки/напоминания: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
	//		- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный
	//		  вызов 
	//		- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат
	//		  на этапе компиляции

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качестве
	//				параметра используется константа, известная компилятору на этапе компиляции).
	//				Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
	//				посредством constexpr-функции:

	
	{	//Например:
		int ar[factorial(3)]; 

		//или
		constexpr auto n = factorial(5);
		int ar1[n];  

		//попробуйте:
		int m = 7;
		//constexpr int n1 = factorial(m); //не вычслить во время компиляции!!!
		//int ar1[n1];						// только если const int m = 7;

		//а так?
		auto n2 = factorial(m); //не вычслить во время компиляции!!!
		//int ar1[n2];
		__asm nop
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 2a. Перевод с помощью пользовательского литерала из двоичного представления строкового
	//в значение, например: строку "100000000" -> в значение 256
	//Проверить результат посредством префикса 0b
	//Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b
	//логично использовать пользовательский литерал с единственным параметром - const char*

	//Так как речь идет о литералах, логично вычислять значения на этапе компиляции
	// => реализуйте пользовательский литерал посредством constexpr - функций
	//Подсказка/напоминание: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>;
	//		- но это выражение может включать вызов другой constexpr – функции,
	//		- которая может быть рекурсивной (если параметр такой функции - это константа,
	//		  компилятор вычислит результат вызова рекурсивной функции на этапе компиляции)

	{
		/*constexpr*/ auto a = 100000000_b;
		/*constexpr*/ auto b = 0_b;
		
		constexpr auto c = 100000000_b2;
		constexpr auto d = 0_b2;

		
		__asm nop

	}

	//Задание 2b. Перевод в строковое двоичное представление, например: 256 -> "0b100000000"
	//Так как строка может быть любой длины, логичнее и проще возвращать объект std::string
	//=> возвращаемое значение не может быть constexpr!
	//Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку
	//придется делать вручную
	//Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>

	{
		std::string sBin= 256_toBinStr;
		std::string sBin1 = 0_toBinStr;
		std::string sBin2 = 2_toBinStr;
		std::string sBin3 = 63_toBinStr;
		__asm nop
	}


	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 3. constexpr - объекты 
	//Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
	//В классе должны быть:
	//	переменные для хранения минимального и максимального значений,
	//	методы для получения каждого из значений
	//	метод для проверки - попадает ли указанное значение в диапазон
	//	метод, который получает любое значение данного типа и формирует результирующее значение:
	//							если принадлежит диапазону, то его и возвращаем
	//							если меньше минимального значения, возвращаем минимальное
	//							если больше максимального значения, возвращаем максимальное

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции. 

	{

		constexpr int a = mmx(1, 2).getMax(); // 2
		constexpr int a1 = mmx(1, 8).getMin(); // 1
		constexpr bool a2 = mmx(1, 3).isIn(2); // true
		constexpr int a3 = mmx(1, 2).inInD(5); // 2



		__asm nop
	}
	/***************************************************************/
//Задание 4.
	/*
	Реализуйте шаблон функции для печати любых последовательностей 
	(vector, list, deque, set и встроенного массива), которые могут содержать:
	•	как объекты любого типа,
	•	так и указатели на объекты любого типа 
	(указатели распечатывать неинтересно => в этом случае следует получать значение по адресу)
	Подсказки: if constexpr
	*/
	{
		std::vector<int> vi{ 1,2,3 };
		std::list<int> li{ 3,4,5 };
		std::deque<int> di{ 6,7,8 };
		std::set<int> si{ 1,2,3 };
		int mi[] = { 9,8,7,6 };

		std::vector<int*> vpi; for (int& a : vi)vpi.push_back(&a);
		std::list<int*> lpi; for (int& a : li)lpi.push_back(&a);
		std::deque<int*> dpi; for (int& a : di)dpi.push_back(&a);
		std::set<int*> spi; for (int& a : vi)spi.insert(&a);
		int* mpi[] = { &mi[0],&mi[1],&mi[2],&mi[3] };


		std::cout << "\n-------printT---------\n";
		printT(vi); std::cout << "\n";
		printT(li); std::cout << "\n";
		printT(di); std::cout << "\n";
		printT(si); std::cout << "\n";
		printT(mi); std::cout << "\n";
		std::cout << "\n--------printT*--------\n";
		printT(vpi); std::cout << "\n";
		printT(lpi); std::cout << "\n";
		printT(dpi); std::cout << "\n";
		printT(spi); std::cout << "\n";
		printT(mpi); std::cout << "\n\n";


		/*printT(&vi); std::cout << "\n";
		printT(&li); std::cout << "\n";
		printT(&di); std::cout << "\n";
		printT(&si); std::cout << "\n";
		printT(&mi); std::cout << "\n\n";*/
	}

	/***************************************************************/
	//Задание 5.
		/* Реализуйте шаблон функции сложения двух значений.
		Если первое слагаемое является вектором, то все элементы вектора 
		нужно увеличить на значение второго параметра. 
		При этом элементы вектора и второй параметр должны быть одного и того же типа.
		Подсказки: if constexpr, is_same
		*/
	{
		auto a = sum(3, 3);
		std::cout << a<<"\n";
		
		auto b = sum(std::vector<double>{2, 2.2, 3}, 1.1);
		printT(b);
	}


	/***************************************************************/
//Задание 6.
	/* 	Реализуйте шаблон функции вывода на печать значений элементов любого 
	адаптера (stack, queue, priority_queue)
	Подсказки: if constexpr, is_same
	//Предусмотрите вывод значений, если в адаптере хранятся указатели.
	*/
	{
		std::deque<int> d1{ 1,2,3 };
		std::deque<int> d2{ 4,5,6 };
		std::vector<int> v3{ 7,8,9 };

		std::stack<int> si{ d1};
		std::queue<int> qi{ d2 };
		std::priority_queue<int> pqi{ std::less<int>(),v3 };

		std::stack<int*> spi; for (int& a : d1)spi.push(&a);
		std::queue<int*> qpi; for (int& a : d2)qpi.push(&a);
		std::priority_queue<int*> pqpi; for (int& a : v3)pqpi.push(&a);

		std::cout << "\n-----------------------------\n";
		printAdaptor(si); std::cout << "\n";
		printAdaptor(qi); std::cout << "\n";
		printAdaptor(pqi); std::cout << "\n-----------------------------\n"; 
		
		printAdaptor(spi); std::cout << "\n";
		printAdaptor(qpi); std::cout << "\n";
		printAdaptor(pqpi); std::cout << "\n";


	}

	/***************************************************************/
//Задание 7.
	/* 	Реализуйте шаблон constexpr функции Smth(), которая должна возвращать
	значения разного типа
	Подсказки: constexpr, if constexpr
	*/
	//constexpr int res1 = /*<вызов Smth()>;*/ //res1 = 1
	//constexpr double res2 = /*<вызов Smth()>; */ //res2 = 2.2
	//  /*constexpr???*/ std::string res3 = /*<вызов Smth()>; */ //res3 = "abc"

	constexpr int res1 = Smth(1);//res1 = 1
	constexpr double res2 = Smth(2.2);//res2 = 2.2
	/*constexpr*/  std::string res3 = Smth("abc");//res3 = "abc"

	//std::string не может быть constexpr


	//***************************************************************/
	//Задание 8.

		/*Пользовательский deduction guide – для вывода типов параметров шаблона
		Задан шаблон класса, который инкапсулирует внедренный ограниченный массив известной
		размерности с элементами любого типа. */
		/*
		template<typename T, size_t size> class MyArray
			{
				T ar[size]; //как обеспечить инициализацию элементов 
				базового типа по умолчанию нулем?
				…
				public:
				MyArray(const T*[, возможно другие параметры]);


			};

		*/
		
		//Требуется обеспечить работоспособность приведенных примеров использования.
	{
		MyArray<int, 5> ar1;//MyArray<int,5>
		MyArray<char, 5> ar2{"ABCqwerty"};//MyArray<char,5>

		MyArray ar3{"ABC"}; //MyArray<char,4>

		int ar[] = { 1,2,3 };
		MyArray ar4{ ar };

		int r = 0;//прорсто точка останова
	}
		


}
