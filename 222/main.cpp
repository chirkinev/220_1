
#include <string>
#include <iostream>
#include <vector>
#include <list>
#include <set>
#include <deque>
#include <map>
//#include "func.h"
#include"xVector.h"
//Лабораторная работа №2
//
//initializer_list, move, default, delete, move итераторы
//
//
//Задание 1. Создайте класс, который должен предоставлять 
// функциональность вектора с УНИКАЛЬНЫМИ значениями любого типа в заданном диапазоне.
//
//Например:
//В нашей структуре хранятся целые с уникальными значениями и данных задан 
// диапазон[1, 10].Пользователь хочет добавить в наш вектор{ 2,-1,3,33, 5,2 }.
//  В результате в нашем векторе должны храниться значения{ 2,3,5 }
//Внимание: при инициализации или присваивании НЕ нужно менять порядок значений, 
// заданный пользователем!При наличии повторяющихся значений нужно оставить первое!
//•	Для хранения элементов используйте std::vector.
//
//o	Вариант 1 : использовать std::vector в качестве внедренного объекта
//o	Вариант 2 : наследовать свой класс от std::vector – при этом важно 
// каким должен быть спецификатор наследования
//Реализовать оба варианта!
//•	Реализуйте конструктор, который может принимать любое количество 
// значений(значения могут повторяться)
//•	Реализуйте метод добавления любого количества значений(значения могут повторяться)
//•	Реализуйте метод удаления любого количества значений(значения могут повторяться)
//•	Предусмотрите возможность изменения диапазона хранимых значений
//•	Реализуйте метод сортировки, который будет принимать в качестве параметра 
// условие сортировки(по возрастанию / по убыванию / по модулю…)
//•	и другие(полезные на Ваш взгляд) методы
//•	явно обозначьте – какие методы вы делегируете сгенерировать компилятору автоматически
//•	реализуйте возможность копирования из нашей структуры данных значения 
// в другое хранилище, например:
//vector<int> v;
//std::copy(my.begin(), my.end(), …);
//
//Задание 2. Реализуйте шаблон класса MyUniquePTR, который является 
// оберткой для указателя на объект любого типа.
//Задача – класс должен обеспечивать единоличное владение динамически
//  создаваемым объектом.Проверить функционирование шаблона на примере MyString :
//{
//	MyUniquePTR<MyString> p1(new MyString(“abc”));
//	std::cout << p1->GetString();
//	p1->SetNewString(“qwerty”);
//	MyString  s2 = *p1;
//	//MyUniquePTR< MyString > p2=p1; //здесь компилятор должен выдавать ошибку => 
//	Исправьте!
//		If(p1) { std::cout << ”No object!” } //а это должно работать
//	MyUniquePTR< MyString > p3(new MyString(“vvv”));
//	//p3 = p2; //и здесь компилятор должен выдавать ошибку
//	vector< MyUniquePTR< MyString >> v; //как проинициализировать???
//	list< MyUniquePTR< MyString >> l;
//	//как скопировать из v в l ???
//}
//
using namespace std;
int main()
{
	cout << "\n";
	interval<int> = { 1,20 }; //можно так интервал задать
	xVector<double>::setInterval(1, 20); // а можно так
	xVector<double> xVdouble{ 2,-1,3,33, 5,2 };
	xVector<int> xVint{ 14,-1,3,33, 15,2 };
	xVector<int> xVint2;
		xVint2.add({ 12,-10,19,303, 5,15 });

	PrintAnyCont(xVint);	cout << "\n";
	PrintAnyCont(xVdouble);	cout << "\n\n";
	//PrintAnyCont(list<double>{4,8,2.2});
	xVint.add({ 5,6,0 }); //можно списком добавлять
	xVint.add(xVint2); // можно с другого вектора
	xVint.add(7); // а можно по 1 элементу
	PrintAnyCont(xVint);	cout << "\n\n";

	xVint.del(7); //Можно по 1 убирать
	xVint.del({ 51,6,0 });// можно по кучке
	xVint=xVint-xVint2; // а можно и так
	PrintAnyCont(xVint);	cout << "\n";

	xVint = xVint + xVint2;// так тоже можно добавлять
	PrintAnyCont(xVint);	cout << "\n";
	xVint.resetInterval(1, 10);// уменьшаем интевал с выкидыванием лишнего
	PrintAnyCont(xVint);	cout << "\n";

	interval<int> = { -20,30 };
	xVint.add({ -5,-6,-12,7,-3,10 });// накидаем значений, подготовливаем к сортировке
	PrintAnyCont(xVint);	cout << "\n\n";
	xVint.xsort(xVector<int>::sortMetod::up); // по возрастанию
	PrintAnyCont(xVint);	cout << "\n";
	xVint.xsort(xVector<int>::sortMetod::down);// по убыванию
	PrintAnyCont(xVint);	cout << "\n";
	xVint.xsort(xVector<int>::sortMetod::abs); // по модулю
	PrintAnyCont(xVint);	cout << "\n";
return(0);
}